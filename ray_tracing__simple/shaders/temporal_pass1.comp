#version 460
#extension GL_GOOGLE_include_directive : enable

// Inputs (sampled)
layout(set=0, binding=0) uniform sampler2D  uHistMomentsPrev;
layout(set=0, binding=1) uniform sampler2D  uNormalPrev;
layout(set=0, binding=2) uniform sampler2D  uDepthPrev;
layout(set=0, binding=3) uniform sampler2D  uNormalCurr;
layout(set=0, binding=4) uniform sampler2D  uDepthCurr;
layout(set=0, binding=5) uniform sampler2D  uMotion;          // RG in **pixels**
layout(set=0, binding=6) uniform sampler2D  uShadowNoisy;     // R in [0,1]

// Outputs
layout(set=0, binding=7, rgba16f) uniform image2D outHistMoments; // R=mean_t, G=m2_t
layout(set=0, binding=8, rgba16f) uniform image2D outDebug;       // debug visual

layout(push_constant) uniform Params {
  float tauZ;
  float tauN;
  float clampK;
  float alphaUse;
  int   firstFrame;
  int   debugMode;   // NEW: 0=off, 1=reuse mask, 2=varPrev, 3=spatialVar, 4=band, 5=dz/nz, 6=alpha, 7=curr/meanPrev/meanT
} pc;

layout(local_size_x = 8, local_size_y = 8) in;

// --- small helper: 3x3 spatial variance on current noisy shadow ---
float spatialVariance3x3(ivec2 p, ivec2 sz)
{
  float sum=0.0, sum2=0.0;
  int cnt=0;
  for(int dy=-1; dy<=1; ++dy)
  for(int dx=-1; dx<=1; ++dx){
    ivec2 q = clamp(p + ivec2(dx,dy), ivec2(0), sz-ivec2(1));
    float s = texelFetch(uShadowNoisy, q, 0).x;
    sum  += s;
    sum2 += s*s;
    cnt++;
  }
  float m  = sum  / float(cnt);
  float m2 = sum2 / float(cnt);
  return max(m2 - m*m, 0.0);
}

void main()
{
  ivec2 p   = ivec2(gl_GlobalInvocationID.xy);
  ivec2 sz  = textureSize(uDepthCurr, 0);
  if(any(greaterThanEqual(p, sz))) return;

  // Current guides
  vec3  n0  = texelFetch(uNormalCurr, p, 0).xyz;
  float z0  = texelFetch(uDepthCurr,  p, 0).x;

  // Motion: current pixel -> previous pixel (in pixels)
  vec2 mv      = texelFetch(uMotion, p, 0).xy;
  vec2 prevPix = vec2(p) - mv;
  vec2 prevUV  = (prevPix + 0.5) / vec2(sz);

  bool prevIn = all(greaterThanEqual(prevUV, vec2(0.0))) &&
                all(lessThan(prevUV,  vec2(1.0)));

  // Previous history + guides
  vec2  hist = prevIn ? texture(uHistMomentsPrev, prevUV).rg : vec2(0.0);
  vec3  n1   = prevIn ? texture(uNormalPrev, prevUV).xyz : vec3(0.0);
  float z1   = prevIn ? texture(uDepthPrev,  prevUV).x   : 3.4e38;

  // Current noisy sample
  float curr = texelFetch(uShadowNoisy, p, 0).x;

  // Reuse test
  bool reuse = (pc.firstFrame == 0) && prevIn;
  float nz = 0.0, dz = 0.0;
  if (reuse) {
    vec3 N0 = normalize(n0);
    vec3 N1 = normalize(n1);
    nz = dot(N0, N1);
    dz = abs(z0 - z1);
    reuse = (dz < pc.tauZ) && (nz > pc.tauN);
  }

  float meanPrev = hist.r;
  float m2Prev   = hist.g;
  float varPrev  = max(m2Prev - meanPrev*meanPrev, 0.0);

  // Band clamp
  float band = pc.clampK * sqrt(max(varPrev, 0.0));
  float used = reuse ? clamp(curr, meanPrev - band, meanPrev + band) : curr;

  // EMA (temporal)
  float alpha = reuse ? pc.alphaUse : 1.0;
  float meanT = mix(meanPrev, used,       alpha);
  float m2T   = mix(m2Prev,   used*used,  alpha);

  // Spatial-variance fallback when history rejected
  if (!reuse) {
    float varS = spatialVariance3x3(p, sz);
    meanT = curr;
    m2T   = curr*curr + varS;  // encode varS into m2
  }

  // Optional: never underestimate variance
  {
    float varT = max(m2T - meanT*meanT, 0.0);
    float varS = spatialVariance3x3(p, sz);
    float varF = max(varT, varS * 0.5); // safety factor
    m2T = meanT*meanT + varF;
  }

  imageStore(outHistMoments, p, vec4(meanT, m2T, 0,0));

  // --- DEBUG OUTPUT ---
  if (pc.debugMode != 0) {
    vec4 dbg = vec4(0);
    if (pc.debugMode == 1) {           // reuse mask
      dbg = reuse ? vec4(0,1,0,1) : vec4(1,0,0,1);
    } else if (pc.debugMode == 2) {    // temporal variance
      float v = clamp(sqrt(varPrev), 0.0, 1.0);
      dbg = vec4(v,v,v,1);
    } else if (pc.debugMode == 3) {    // spatial variance
      float vs = clamp(sqrt(spatialVariance3x3(p, sz)), 0.0, 1.0);
      dbg = vec4(vs,vs,vs,1);
    } else if (pc.debugMode == 4) {    // band (width)
      float w = clamp(band, 0.0, 1.0);
      dbg = vec4(w,w,w,1);
    } else if (pc.debugMode == 5) {    // dz / nz
      float dzN = clamp(dz * 10.0, 0.0, 1.0);      // scale depth diff for visibility
      float nzN = clamp(0.5 * (nz + 1.0), 0.0, 1.0); // [-1..1] -> [0..1]
      dbg = vec4(dzN, nzN, 0, 1);
    } else if (pc.debugMode == 6) {    // alpha used
      dbg = vec4(alpha, alpha, alpha, 1);
    } else if (pc.debugMode == 7) {    // R=curr, G=meanPrev, B=meanT
      dbg = vec4(curr, meanPrev, meanT, 1);
    }
    imageStore(outDebug, p, dbg);
  }
}
