#version 460
#extension GL_GOOGLE_include_directive : enable

// Inputs (sampled)
layout(set=0, binding=0) uniform sampler2D  uHistMomentsPrev; // R=mean_prev, G=m2_prev
layout(set=0, binding=1) uniform sampler2D  uNormalPrev;
layout(set=0, binding=2) uniform sampler2D  uDepthPrev;
layout(set=0, binding=3) uniform sampler2D  uNormalCurr;
layout(set=0, binding=4) uniform sampler2D  uDepthCurr;
layout(set=0, binding=5) uniform sampler2D  uMotion;          // RG pixels
layout(set=0, binding=6) uniform sampler2D  uShadowNoisy;     // R in [0,1]

// Output (storage)
layout(set=0, binding=7, rgba16f) uniform image2D outHistMoments; // R=mean_t, G=m2_t

// Your UBO with viewportSize (not strictly required here if we use texelFetch sizes)
layout(push_constant) uniform Params {
    float tauZ;      // e.g., 0.02
    float tauN;      // e.g., 0.97
    float clampK;    // e.g., 1.0
    float alphaUse;  // e.g., 0.1
    int   firstFrame;
} pc;

layout(local_size_x = 8, local_size_y = 8) in;

void main() {
    ivec2 pix  = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = textureSize(uDepthCurr, 0);
    if (any(greaterThanEqual(pix, size))) return;

    // Current guides
    vec3  n0  = texelFetch(uNormalCurr, pix, 0).xyz;
    float z0  = texelFetch(uDepthCurr,  pix, 0).x;

    // Motion: map current pixel -> previous pixel
    vec2 mv      = texelFetch(uMotion, pix, 0).xy;    // pixels
    vec2 prevPix = vec2(pix) - mv;
    vec2 prevUV  = (prevPix + 0.5) / vec2(size);

    // bounds
    bool prevIn = all(greaterThanEqual(prevUV, vec2(0.0))) &&
              all(lessThan(prevUV, vec2(1.0)));


    // Previous history + guides (bilinear for robustness)
    //vec2  hist   = textureLod(uHistMomentsPrev, prevUV, 0.0).rg;
    vec2 hist = prevIn ? texture(uHistMomentsPrev, prevUV).rg : vec2(0.0);
    //vec3  n1     = textureLod(uNormalPrev,      prevUV, 0.0).xyz;
    //float z1     = textureLod(uDepthPrev,       prevUV, 0.0).x;
    vec3  n1 = prevIn ? texelFetch(uNormalPrev, ivec2(prevPixF), 0).xyz : vec3(0.0);
    float z1 = prevIn ? texelFetch(uDepthPrev,  ivec2(prevPixF), 0).x   : 3.4e38;

    // Current noisy sample (shadow visibility)
    float curr = texelFetch(uShadowNoisy, pix, 0).x;

    // Reuse test
    bool reuse = (pc.firstFrame == 0);
    if (reuse) {
        float nz = dot(normalize(n0), normalize(n1));
        float dz = abs(z0 - z1);
        reuse = (dz < pc.tauZ) && (nz > pc.tauN);
    }

    float meanPrev = hist.r;
    float m2Prev   = hist.g;
    float varPrev  = max(m2Prev - meanPrev*meanPrev, 0.0);

    // Band clamp to kill ghosting
    float band = pc.clampK * sqrt(max(varPrev, 0.0));
    float used = reuse ? clamp(curr, meanPrev - band, meanPrev + band) : curr;

    // EMA of moments
    float alpha = reuse ? pc.alphaUse : 1.0;
    float meanT = mix(meanPrev, used,       alpha);
    float m2T   = mix(m2Prev,   used*used,  alpha);

    imageStore(outHistMoments, pix, vec4(meanT, m2T, 0.0, 0.0));

}
